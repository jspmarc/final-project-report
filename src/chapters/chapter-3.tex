\chapter{Analisis dan Rancangan Sistem HILS}

Pada bab ini akan dibahas analisis permasalahan pada sistem simulasi yang sudah
ada. Setelah itu, akan dilakukan analisis dan perancangan terhadap solusi yang
akan dibuat pada buku ini.

\section{Deskripsi Umum Proyek \textit{Capstone}}

Tugas akhir yang dikerjakan oleh tim \textit{capstone} bertujuan untuk memenuhi
kebutuhan tim simulasi pada proyek pengembangan trem otonom. Tim simulasi
dibentuk agar pengujian algoritma kendali dan pengumpulan data tidak harus
dilakukan dengan trem yang nyata. Alasannya adalah untuk keamanan, menghemat
biaya, dan menghemat waktu. Pengujian nyata dengan algoritma yang belum siap
dapat menyebabkan orang atau kendaraan lain ditabrak oleh trem. Selain itu,
dengan simulasi para pengembang tidak perlu terjun ke lapangan di Kota Madiun
dan tidak perlu menyewa trem serta rel untuk melakukan pengujian.

Proyek pengembangan trem otonom sendiri sudah memasuki tahun kedua, akan tetapi
pada tahun pertama belum ada tim simulasi. Program untuk simulasi, baik SILS
(\textit{software-in-the-loop-simulation}) maupun HILS
(\textit{hardware-in-the-loop-simulation}), tidak memiliki waktu pengembangan
yang banyak dan hanya sekadar ada. Oleh karenanya, tim \textit{capstone} perlu
mengimplementasikan atau memperbaiki sistem simulasi HILS agar pengujian HILS
dapat  dilakukan. Selain itu, tim \textit{capstone} juga harus dapat membuat
lingkungan simulasi yang semirip mungkin dengan keadaan di Indonesia serta
membuat beberapa skenario simulasi agar pengujian dapat dilakukan secara
otomatis.

Tugas akhir ini bertujuan untuk membuat sistem simulasi agar HILS lebih reliabel
dan memiliki dengan kinerja yang baik. Program HILS sendiri sudah pernah
diimplementasi pada tahun pertama proyek, akan tetapi implementasinya memiliki
beberapa keluhan yang akan dibahas pada bab ini. Dari keluhan-keluhan tersebut
akan dibahas analisis serta rancangan solusi untuk memperbaiki program HILS yang
ada.

\section{Analisis Masalah Sistem HILS Saat ini}

Sistem simulasi yang ada sudah dapat menghubungkan komputer SILS dengan server
komputer RKB/AGX sehingga sistem simulasi HILS sudah dapat digunakan. Akan
tetapi masih ada keluhan terkait kinerja sistem smulasi HILS, yaitu proses
simulasi yang sangat lambat dan menyebabkan simulasi kurang realistis. Jumlah
transaksi data per detik turun dari 4000 transaksi data per detik pada SILS,
turun menjadi 100-110 transaksi data per detik ketika menggunakan HILS dan
layanan web. Target kecepatan simulasi yang harus dicapai untuk dianggap cukup
cepat adalah CARLA dapat berjalan stabil dengan minimum 2 FPS (\textit{frames
per second}).

Padahal kedua komputer pada sistem HILS sudah terhubung pada jaringan lokal
(LAN) yang artinya latensi dan gangguan jaringan akan minimum, jika ada.
Oleh karena itu, kemungkinan \textit{bottleneck} terdapat pada implementasi
mekanisme komunikasi. Implementasi mekanisme komunikasi menggunakan sebuah
layanan web yang arsitekturnya dapat dilihat pada diagram di Gambar
\ref{chapter-2-old-hils}. Proses pada implementasi HILS yang lama dapat dilihat
pada diagram \textit{sequence} di Gambar
\ref{chapter-3-sequence-diagram-old-hils}. Pada proses pengiriman data, terdapat
delapan operasi I/O yang berjalan secara sinkronis, yaitu
\begin{enumerate}
	\item penulisan CARLA \textit{measurement} ke \textit{file} di SILS,
	\item pembacaan CARLA \textit{measurement} dari \textit{file} di SILS,
	\item pengiriman CARLA \textit{measurement} menggunakan HTTP dari SILS ke
		layanan web,
	\item penulisan CARLA \textit{measurement} ke basis data pada layanan web,
	\item permintaan HTTP dari AGX/RKB ke layanan web untuk membaca data,
	\item pembacaan CARLA \textit{measurement} dari basis data pada layanan web,
	\item penulisan CARLA \textit{measurement} ke \textit{file} pada AGX/RKB,
		dan
	\item pembacaan CARLA \textit{measurement} dari \textit{file} pada AGX/RKB.
\end{enumerate}

\begin{figure}[h!]
    \centering
	\includegraphics[width=1.0\textwidth]{resources/chapter-3/sequence-diagram-old-hils-process.png}
	\caption{Proses pengiriman data CARLA \textit{measurement} kondisi saat ini}
    \label{chapter-3-sequence-diagram-old-hils}
\end{figure}

Dari diagram \textit{sequence} dapat diperkiran \textit{bottleneck} disebabkan
banyaknya operasi I/O sinkronis yang berdampak pada \textit{overhead} operasi
I/O. \textit{Overhead} operasi I/O a\-kan menjadi lebih buruk lagi apabila data
yang dikirimkan berukuran besar, misalnya data sensor kamera. Selain itu, sistem
yang ada juga lebih rumit dari seharusnya. Terdapat perantara berupa layanan web
dan basis data padahal data bisa saja dikirimkan langsung dari komputer SILS ke
komputer AGX/RKB.

Selain masalah kinerja, terdapat keluhan juga karena sistem HILS yang ada belum
menggunakan data sensor. Sistem HILS yang ada masih memanfaatkan CARLA
\textit{measurement}. Data dari CARLA \textit{measurement} mencakup posisi x,
posisi y, kecepatan, dan jarak relatif. Data-data ini dibutuhkan untuk
mendapatkan oleh algoritma kendali, akan tetapi seharusnya didapatkan dari
sensor. Pada sistem HILS saat ini, data \textit{measurement} tersebut didapatkan
dengan memanggil fungsi dari API Python CARLA.

\section{Analisis Solusi}

Dari analisis masalah, didapatkan dua keluhan pada implementasi sebelumnya,
yaitu masalah kinerja dan belum ada dukungan terhadap data sensor. Dari
keluhan-keluhan tersebut, dibutuhkan sebuah solusi yang dapat meningkatkan
kinerja HILS dan dapat menggunakan data sensor. Sensor-sensor yang harus
didukung pada solusi adalah sensor kamera, lidar, dan GNSS. Ketiga sensor harus
dapat digunakan secara bersamaan.

Dari kebutuhan-kebutuhan tersebut, ada dua buah alternatif solusi: melakukan
peningkatan (\textit{upgrade}) program HILS yang sudah ada atau menulis ulang
program HILS. Dari kedua alternatif, dipilih alternatif penulisan ulang program
HILS. Alasannya adalah karena pada solusi pertama memiliki kompleksitas yang
lebih tinggi karena ada lebih banyak komponen pada sistem. Selain itu, layanan
web pada solusi pertama tidak terintegrasi langsung pada program utama, baik di
komputer SILS maupun komputer AGX/RKB. Layanan web membutuhkan program bantuan
yang berkomunikasi dengan program utama menggunakan \textit{file}. Hal ini ingin
dihindari karena adanya \textit{overhead} I/O. Selain itu, meskipun layanan web
memiliki \textit{coupling} yang rendah dengan kedua program utama, kohesinya
juga rendah. Karena kedua alasan itulah dinilai alternatif kedua akan lebih
mudah untuk dilaksanakan.

Selanjutnya adalah pemilihan mekanisme komunikasi. Berdasarkan studi literatur,
terdapat dua alternatif untuk mekanisme komunikasi, yaitu ROS dan ZeroMQ. ROS
sendiri adalah salah satu kerangka kerja dan mekanisme komunikasi yang sering
digunakan untuk kebutuhan simulasi robot. Akan tetapi, karena kendala teknis ROS
tidak dapat dipilih. Oleh karena itu, dari pilihan antara ROS dan ZeroMQ,
dipilih ZeroMQ.

Kendala teknis yang menyebabkan ROS tidak dapat digunakan adalah ketidakcocokan
antara versi ROS di komputer SILS dengan komputer AGX/RKB. Komputer SILS
menggunakan sistem operasi Ubuntu 20.04 yang menggunakan ROS 2, sedangkan
komputer AGX/RKB menggunakan sistem operasi Ubuntu 18.04 yang menggunakan ROS 1.
ROS 2 dan ROS 1 memiliki arsitektur komunikasi yang berbeda, hal ini menyebabkan
ketidakcocokan antara ROS 2 dengan ROS 1. Meskipun ada program untuk
menjembatani ROS 2 dan ROS 1, hal tersebut dihindari karena adanya kemungkinan
penambahan latensi.

\section{Rancangan Solusi}

Karena program utama di sisi komputer SILS dan AGX/RKB sudah ada atau sedang
dikerjakan, maka dipililh solusi dalam bentuk pustaka agar pemuatan bisa
dilakukan secara modular dan independen dari kedua program utama. Menciptakan
\textit{coupling} yang rendah antara pustaka dengan kedua program utama. Selain
itu, keuntungan pustaka adalah program GRS jadi dapat memilih untuk memuat
pustaka yang akan dibuat atau tidak pada proses kompilasi sehingga dapat sedikit
menghemat \textit{resource} terutama memori. Pustaka yang dibuat akan disebut
``hils-connector''.

Pustaka yang akan dibuat ada dua, yaitu pustaka C++11 untuk program GRS di
komputer AGX/RKB dan pustaka Python 3 untuk \textit{agent} program
\textit{scenario runner}. Pustaka Python akan disebut ``\textit{producer}''
karena memproduksi data sensor. Pustaka C++ akan disebut ``\textit{consumer}''
karena mengonsumsi data sensor. Selain data sensor, juga akan ada data berupa
kontrol/perintah dengan format sebuah \texttt{int} yang dikirim dari
\textit{consumer} ke \textit{producer} setelah data sensor berhasil diproses.

Lalu untuk fitur pustaka itu sendiri, pustaka akan langsung berkomunikasi satu
sama lain tanpa menggunakan perantara. Hal ini membuat solusi lebih sederhana
dan mengurangi \textit{overhead} untuk berkomunikasi dengan perantara. Pustaka
juga akan menyediakan API untuk mengirimkan data dan menerima data. Untuk
mendukung berbagai jenis sensor, pustaka juga akan memiliki fitur
\textit{parsing}, serialisasi, dan deserialisasi untuk sensor GNSS, kamera, dan
lidar.

API yang disediakan oleh pustaka ``producer'' akan langsung mengkonsumsi data
sensor dari CARLA sehingga pengguna pustaka tidak perlu melakukan modifikasi
apapun pada data sensor CARLA. Begitu juga pada pustaka ``consumer''. Balikan
API akan disesuikan sehingga pengguna pustaka dapat langsung menggunakan data
sensor dan langsung ``memasukkannya'' ke sensor virtual NVIDIA DriveWorks.

Lalu, untuk mengurangi berbagai \textit{overhead} tambahan yang dapat muncul
karena operasi pada jaringan, dipilih mekanisme komunikasi menggunakan ZeroMQ.
ZeroMQ adalah \textit{message queue} sehingga cocok digunakan untuk operasi
asinkron yang sesuai dengan pengiriman data sensor dari CARLA. Lalu, ZeroMQ juga
sangat dekat dengan TCP, tapi tanpa kompleksitas \textit{raw} TCP. Hal tersebut
dikarenakan salah satu tujuan utama ZeroMQ adalah mengurangi latensi hinga
sesedikit mungkin dan memaksimalkan \textit{throughput}. ZeroMQ juga tidak
memiliki \textit{broker}, hal ini sesuai dengan keinginan menghilangi perantara
sehingga \textit{producer} dan \textit{consumer} dapat langsung berkomunikasi
satu sama lain.

Dari solusi pustaka yang ditawarkan, dapat dibentuk sebuah arsitektur sistem
HILS. Arsitektur ini dapat dilihat pada diagram \textit{deployment} di Gambar
\ref{chapter-3-new-architecture}. Lalu, gambaran kasar proses pada sistem
simulasi untuk satu \textit{step} simulasi dapat dilihat pada diagram
\textit{sequence} di Gambar \ref{chapter-3-new-sequence}. Perlu dicatat bahwa
HILS \textit{agent} adalah \textit{agent} yang digunakan pada program
ScenarioRunner.

\begin{figure}[h!]
    \centering
    \includegraphics[width=1.0\textwidth]{resources/chapter-3/deployment-diagram-new-hils.png}
    \caption{Arsitektur Sistem HILS Baru}
    \label{chapter-3-new-architecture}
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics[width=1.0\textwidth]{resources/chapter-3/sequence-diagram-new-hils-kasar.png}
		\caption{Gambaran kasar proses satu \textit{step} simulasi}
    \label{chapter-3-new-sequence}
\end{figure}
