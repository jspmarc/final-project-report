\chapter{Studi Literatur}

Pada bab ini, Penulis akan menguraikan hasil literatur dalam penyusunan tugas
akhir ini. Subbab pertama membahas simulator CARLA, yaitu perangkat lunak yang
digunakan sebagai alat simulasi. Subbab kedua menjelaskan NVIDIA Pegasus yang
akan digunakan sebagai mesin untuk menjalankan algoritma \textit{decision
      making} di lingkungan simulasi dan \textit{production}. Lalu, pada subbab
ketiga akan dibahas beberapa cara komunikasi yang dapat digunakan pada sistem
terdistribusi. Terakhir, subbab keempat akan membahas penelitian-penelitian
terkait simulasi \textit{autonomous vehicle} menggunakan CARLA.

\section{Simulator CARLA}
\blindtext

% TODO: Masukin hubungan dengan NVIDIA Pegasus

\section{NVIDIA Pegasus}

NVIDIA Pegasus adalah salah satu produk cetusan NVIDIA Corporation di bawah
lini produk NVIDIA Drive PX. Nama pasar dari NVIDIA Pegasus adalah NVIDIA Drive
PX Pegasus. Lini produk NVIDIA Drive sendiri merupakan platform komputer untuk
memberikan fungsionalitas bantuan mengemudi pada kendaraan bermotor.

\begin{figure}
      \begin{center}
            \includegraphics[height=0.5\textheight]{resources/chapter-2/pegasus.png}
            \caption{NVIDIA Pegasus \parencite{trilaksono_laporanRispro}}
      \end{center}
\end{figure}

Mengutip dari \parencite{oh_2017}, NVIDIA Pegasus adalah komputer yang
mendukung pengemudian \textit{autonomous} secara penuh. Artinya, NVIDIA Pegasus
dapat digunakan untuk membuat sebuah kendaraan bermotor menjadi
\textit{autonomous vehcile} jika sensor dan algoritma yang digunakan tepat.

NVIDIA Pegasus menggunakan 2 GPU dengan arsitektur post-Volta dan 2 SoC NVIDIA
Xavier. Kombinasi CPU dan GPU ini dapat menghasilkan 320 TOPS (\textit{trillion
      operations/second}) untuk komputasi intelegensi buatan. Untuk koneksi I/O,
NVIDIA Pegasus mendukung sampai dengan 16 kamera (6 di antaranya adalah lidar).

% TODO: Jelasin/masukin hubungannya dengan CARLA dan jelasin juga kalo NVIDIA
% Pegasus ini komputer biasa yang bisa menggunakan berbagai OS (buat transisi ke
% rosbridge)

\section{Metode Komunikasi antara Simulator CARLA dan NVIDIA Pegasus}

Pada keadaan yang ada, komunikasi antara simulator CARLA dengan NVIDIA Pegasus
perantara menggunakan \textit{web service} yang berbasis HTTP. Penggunaan HTTP
pada \textit{web service} menjadi \textit{bottleneck}/penghambat kinerja
terbesar sistem simulasi. Ketika dilakukan secara SILS (\textit{software in the
      loop simulation} tanpa NVIDIA Pegasus) didapatkan kinerja 4000 transaksi per
detik, sedangkan ketika NVIDIA Pegasus ditambahkan ke sistem (menjadi HILS,
\textit{hardware in the loop simulation}) didapatkan 100--110 transaksi per
detik \parencite{trilaksono_laporanRispro}. Oleh karena itu, dibutuhkan protokol
atau metode komunikasi lain yang dapat meningkatkan kinerja jalur komunikasi.
Selain itu, jalur komunikasi yang digunakan harus dapat mengirimkan pesan berupa
teks \textit{string}, larik angka, atau data \textit{binary} (misalnya gambar).

\begin{figure}
      \begin{center}
            \includegraphics[width=1.0\textwidth]{resources/chapter-2/komunikasi
                  data pada simulasi.png}
            \caption{Arsitektur komunikasi data pada HILS \parencite{trilaksono_laporanRispro}}
      \end{center}
\end{figure}

Beberapa alternatif metode/protokol jalur komunikasi dapat digunakan untuk menghubungkan
sistem ini akan dibahas pada subbab ini. Protokol atau metode tersebut adalah rosbridge,
RPC, dan \textit{messaging system}.

\subsection{Rosbridge}

Rosbridge adalah protokol komunikasi yang menambahkan antarmuka pada komputer
dengan sistem operasi ROS. Antarmuka yang ditambahkan membuat komputer dapat
\textit{publish} dan \textit{subscribe} ke topik ROS dalam format JSON. Selain
itu, antarmuka tersebut memungkinkan memanggil \textit{service} ROS di antara
hal-hal lainnya.

Spesifikasi lengkap untuk rosbridge tertuang di proyek \parencite{ros_bridge}.
Pada subbab ini, spesifikasi rosbridge akan dijelaskan secara singkat.

Secara arsitektur, protokol rosbridge menggunakan protokol WebSocket untuk
lapisan transpornya. Protokol WebSocket sendiri berjalan di atas protokol TCP
yang artinya protokol rosbridge menjamin data akan sampai dengan urutan yang
benar.

Protokol rosbridge menggunakan format JSON untuk pesannya. Pesan yang valid
harus mengandung \textit{field} \texttt{"op"}. \textit{Field} tersebut digunakan
untuk menentukan jenis pesan. Pesan juga dapat mengandung \textit{field}
\texttt{"id"} yang digunakan sebagai penanda transaksi atau keterhubungan antara
beberapa pesan. Selain kedua \textit{field} tersebut, pesan rosbridge juga dapat
mengandung \textit{field} lainnya tergantung jenis \texttt{"op"}.

\begin{lstlisting}[language=JSON, caption=contoh pesan valid pada lapisan transpor rosbridge]
{
    "op": "fragment"
}
\end{lstlisting}

Jenis pesan yang dapat dikirim dapat dibagi menjadi 3 kategori.
Kategori-kategori tersebut akan diuraikan sebagai berikut.
\begin{enumerate}
      \item Pesan kompresi atau transformasi dengan kode \texttt{op}:
            \begin{itemize}
                  \item \texttt{fragment} untuk pesan yang terpecah-pecah, atau
                  \item \texttt{png} untuk pesan yang berupa berkas PNG.
            \end{itemize}
      \item Pesan status rosbridge:
            \begin{itemize}
                  \item \texttt{set\_status\_level} untuk mengatur tingkat pelaporan
                        rosbridge, atau
                  \item \texttt{status} untuk pesan status.
            \end{itemize}
      \item Pesan operasi:
            \begin{itemize}
                  \item \texttt{advertise} untuk menandakan pengirim sedang
                        mempublikasikan suatu topik,
                  \item \texttt{unadvertise} untuk menandakan pengirim berhenti
                        mempublikasikan suatu topik,
                  \item \texttt{publish} untuk pesan ROS yang dipublikasikan ke
                        suatu topik,
                  \item \texttt{subscribe} untuk meminta ``berlangganan'' ke suatu
                        topik,
                  \item \texttt{unsubscribe} untuk meminta berhenti ``berlangganan'',
                  \item \texttt{call\_service} untuk memanggil suatu layanan,
                  \item \texttt{advertise\_service} untuk menandakan pengirim sedang
                        mempublikasikan suatu layanan, \item \texttt{unadvertise\_service}
                        untuk menandakan pengirim berhenti mempublikasikan suatu layanan,
                  \item \texttt{service\_request} untuk \textit{request}/permintaan
                        ke suatu layanan, atau \item \texttt{service\_response} untuk
                        hasil/balasan permintaan ke suatu layanan.
            \end{itemize}
\end{enumerate}

Pesan yang dikirim melalui protokol rosbridge dapat di-\textit{encode} dengan 3
format. Format pertama adalah \textit{raw} JSON. Dalam format ini, pesan yang
dikirim akan berupa \textit{string} biasa. Selain itu, pesan yang dikirim juga
dapat dikompresi dengan format CBOR (\textit{concise binary object
      representation}) atau CBOR-\textit{raw}. Pesan dalam format CBOR akan berbentuk
pesan \textit{binary}. Sehingga pesan harus didekompresi oleh penerima untuk
mendapatkan pesan aslinya.

Perbedaan antara CBOR dengan CBOR-\textit{raw} adalah format pesannya. Pada
CBOR-\textit{raw}, pesan dikirim dalam format serialisasi ROS. Format
serialisasi ROS digunakan untuk mengirimkan data antar-ROS \textit{node} dan
pada berkas \texttt{bag}\footnote{Format berkas yang digunakan untuk menyimpan
      data pada mesin ROS.}. Keuntungan menggunakan CBOR-\textit{raw} adalah
peningkatan kinerja jika \textit{parsing} hanya sebagian pesan, aplikasi dapat
membaca berkas \texttt{bag}, atau \textit{parsing} pesan ingin dilakukan
seterlambat mungkin atau secara paralel.

\subsection{RPC}

RPC, atau \textit{remote procedure call}, secara teknis bukan protokol,
melainkan sebuah mekanisme untuk menyusun sistem terdistribusi yang
berkomunikasi dengan pola \textit{request/reply}
\parencite{larry_computerNetwork}. RPC memberikan abstraksi kepada pengembang
berupa pemanggilan fungsi secara lokal maupun \textit{remote}, di permukaannya,
memiliki perilaku yang sama. Pemanggilan fungsi \textit{remote} artinya
implementasi fungsi berada di komputer lain di dalam jaringan.

Ketika menggunakan RPC, pengembang tidak perlu tahu pemanggilan sebuah fungsi
dilakukan secara lokal atau \textit{remote}; pengembang hanya tahu pemanggilan
fungsi tersebut akan menghasilkan suatu nilai baru dan dapat (tidak
selalu\footnote{beberapa implementasi RPC mendukung pemanggilan
      \textit{asynchronous} yang tidak harus memberikan sebuah \textit{return}.})
membuat program \textit{blocking} (menunggu) sampai nilai baru tersebut
didapatkan.

Abstraksi RPC didapatkan karena 2 komponen utama pada RPC. Komponen pertama
adalah protokol yang mengurusi pengiriman pesan antara \textit{server/producer}
dan \textit{client/consumer}. Kedua, bahasa pemrograman dan \textit{compiler}
yang dapat membungkus pemanggilan fungsi \textit{remote} menjadi pesan
\textit{request} dan mentranslasikan pesan \textit{request} menjadi pemanggilan
ke fungsi lokal (begitu juga untuk \textit{return} dari pemanggilan fungsi
\textit{remote}).

Secara arsitektur, RPC bisa dibangun di atas protokol TCP sehingga pembuat
implementasi RPC tidak perlu memikirkan keandalan (\textit{reliability})
pengiriman pesan pada implementasinya. Akan tetapi, RPC juga bisa dibangun di
atas protokol UDP atau IP lalu ditambahkan/dibuat lapisan keandalannya sendiri.

Implementasi RPC yang akan dibahas pada subbab ini adalah Apache Thrift. Apache
Thrift juga merupakan implementasi RPC yang akan digunakan untuk membangun jalur
komunikasi antara server NVIDIA Pegasus dengan server simulator CARLA. Apache
Thrift dipilih karena kemampuannya mengirimkan pesan dalam format
\textit{binary}. Selain itu, karena kinerja Apache Thrift lebih baik
dibandingkan dengan HTTP dan implementasi RPC oleh Google, gRPC
\parencite{abernethy_buildingHighPerformanceMSThrift}.

\subsubsection{Apache Thrift}

Apache Thrift adalah sebuah implementasi RPC dalam bentuk \textit{framework}
yang diciptakan oleh Facebook, Inc. (sekarang Meta Platforms, Inc.) lalu
disumbangkan ke Apache Software Foundation. Tujuan utama dari pembuatan Apache
Thrift adalah sebuah jembatan antar-bahasa pemrograman yang memiliki kinerja
tinggi \parencite{agarwal_thrift} sehingga Apache Thrift dapat digunakan lintas
bahasa pemrograman.

\subsection{\textit{Messaging System}}

\subsubsection{ZeroMQ}

\section{Penelitian Terkait}
\blindtext